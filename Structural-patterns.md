## Façade
Един клас репрезентиращ цяла система от подкласове. С други думи, когато имаме много класове, на които искаме да скрием имплементация или няма нужда да я знаем, тогава използваме Façade. Този клас делегира отговорностите на другите подкласове като клиента не разбира за това. Не трябва да се бърка Façade с Mediator модела, като се спазва условието че първият НЕ добавя никакви нови функционалности на други класове, а просто обединява другите класове и тяхната фунцкионалост в един по висш клас. Подобно на Adapter модела, Façade обгръща други класове, но за разлика от него той просто предоставя опростен интърфейс за използване (Adapter моделът адаптира други интърфейси към нов). Façade моделът често е Singleton понеже има нужда само от една негова инстанция.

### Façade examples
-	Дистанционното на една аудио система – потребитяла няма нужда да знае как се сменят траковете, как се спира, стартира и т.н системата. 
-	Call center-овете – обаждаш се и от другата страна един човек поема цялата работа
-	Ресторант – никой от гостите не вижда какво се случва в кунята, а келнерът предоставя цялата услуга

#### Façade desing pattern
![alt text](https://www.tutorialspoint.com/design_pattern/images/facade_pattern_uml_diagram.jpg "facade")

## Composite
Този модел дава възможноста да третираме един обект самостоятелно или много обекти от същия тип едновременно. Самият клас Composite подобно на единичния обект наследява същия абстрактен клас, но за разлика от единичния обект, той може да третира много единични обекти. Пример от реалния живот е командира на едн армия. Той също е човек и си има собствените свойста и методи, но чрез него ние може да имплементираме същите методи на много войници едновременно. С други думи може да се каже, че Composite моделът има дървовидна структура, като главното звено е звено в същината си, но чрез него може да третираме неговите подзвена.

### Composite examples
-	Директориите в една система. Имаме една-две главни директории, чрез които може да контролираме всички по директнории. Ако имаме много директори, може да кажем че имаме много Composite класове надолу по йерархията.

#### Composite desing pattern
![alt text](http://www-sop.inria.fr/axis/cbrtools/usermanual-eng/Icons/Composite2.gif "composite")

## Decorator
Този модел добавя функционалност към вече съществуващ клас. По този начин една система може да стане по-гъвкава без да нарушава Open-closed принципа. Една от най-големите му ползи и употреби е при разширяването на legacy код. Моделът следва следната структура: създава се клас (декаратор клас), който да наследява абстрактия клас или интърфеса наследяван също така от класа предвиден за разширяване. В конструктора се подава като параметър обект от тип на абстрактния клас и се добавят новите функционалности, които използват подадения обект. Така при инициализирането на класа декоратор, за параметър се подава класа предвиден за разширение. За разлика от Adapter модела, който променя интърфейса на обектите, Decorator моделът само го разширява

### Decorator examples
-	Legacy code
-	Дадена кола искаме вече да има аудио система
-	Панел, защитно фолио на телефон

#### Decorator desing pattern
![alt text](https://www.tutorialspoint.com/design_pattern/images/decorator_pattern_uml_diagram.jpg "decorator")
